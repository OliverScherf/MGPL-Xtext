/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.generator

import java.io.File
import java.net.URL
import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.nio.file.StandardOpenOption
import org.eclipse.core.runtime.FileLocator
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.mwe.internal.core.Workflow
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.mGPL.AnimBlock
import org.xtext.example.mydsl.mGPL.AssStmt
import org.xtext.example.mydsl.mGPL.AttrAss
import org.xtext.example.mydsl.mGPL.Decl
import org.xtext.example.mydsl.mGPL.ForStmt
import org.xtext.example.mydsl.mGPL.IfStmt
import org.xtext.example.mydsl.mGPL.ObjDecl
import org.xtext.example.mydsl.mGPL.Prog
import org.xtext.example.mydsl.mGPL.Stmt
import org.xtext.example.mydsl.mGPL.VarDecl
import org.xtext.example.mydsl.mGPL.impl.ProgImpl

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MGPLGenerator extends AbstractGenerator {

	/*
	 * Kopiere Framework nach res/
	 * Rectangle, Circle Klassen
	 * KeyListener
	 * animations in update Funktion generieren (callback an Framework)
	 */

	MGPLNameProvider np = new MGPLNameProvider

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		copyFramework(fsa)
		val prog = resource.allContents.head as Prog
		val code = generateProg(prog)
		fsa.generateFile(prog.name + ".ts", code)
	}
	
	private def copyFramework(IFileSystemAccess2 fsa) {
		val resDir = new File(System.getenv("PARENT_LOC") + "/res/src/framework")
		for (f : resDir.listFiles)
			fsa.generateFile("framework/" + f.name, new String(Files.readAllBytes(f.toPath)))
	}
	
	def generateProg(Prog p) {
		'''
		import Game from "./framework/Game.js";
		import Rectangle from "./framework/rectangle.js";
		import Triangle from "./framework/Triangle.js";
		import { touches } from "./framework/Collision.js";
		import Circle from "./framework/Circle.js";
		import {arrayOfN} from "./framework/Util.js";
		
		enum «p.name» {
			«generateAttrAssList(p)»
		}

		«generateGlobalVariables(p)»

		'''
	}
		
	
	def generateAttrAssList(Prog p) {
		val at = p.attrAssList.attrAss
		'''
			width = «findAttribute(at, "w", "width")»,
			height = «findAttribute(at, "h", "height")»,
			x = «findAttribute(at, "x")»,
			y = «findAttribute(at, "y")»,
			speed = «findAttribute(at, "speed")»
		'''
	}
	
	def generateGlobalVariables(Prog p) {
		'''
		// global variables
		«FOR d : p.decls.filter[it instanceof VarDecl].map[it as VarDecl]»
			let «d.name»: «np.type(d)»«generateInitValue(d)»;
		«ENDFOR»
		
		// global objects
		«FOR d : p.decls.filter[it instanceof ObjDecl].map[it as ObjDecl]»
			let «d.name»: «np.type(d)»«generateInitValue(d)»;
			 
		«ENDFOR»
		
		//game object
		«generateGame(p)»
		
		// animations
		«FOR ab : p.functions.filter[it instanceof AnimBlock].map[it as AnimBlock]»
			«generateAnimation(ab)»
			 
		«ENDFOR»
		'''
	}
		
	def generateAnimation(AnimBlock ab) {
		'''
		const «ab.name» = («ab.objName»: «np.type(ab.objType)») => {
			«IF ab.stmtBlock !== null»
				«FOR s : ab.stmtBlock.stmts»
				«generateStmt(s)»
				«ENDFOR»
			«ENDIF»
		}
		'''
	}
		
	def CharSequence generateStmt(Stmt s) {
		if (s instanceof IfStmt) {
			return generateIfStrm(s)
		}
		if (s instanceof AssStmt) {
			return generateAssStmt(s)
		}
		if (s instanceof ForStmt) {
			return generateForStmt(s)
		} 
		return ""
	}
	
	def CharSequence generateAssStmt(AssStmt s) {
		return '''«s.^var.name» = «np.resolveExpression(s.expr)»;'''
	}
	
		
	def generateForStmt(ForStmt s) {
		'''
		for («generateAssStmt(s.initAssStmt)» «np.resolveExpression(s.cond)»; «generateAssStmt(s.afterthoughAssStmt)» {
			«FOR st : s.stmtBlock.stmts»
			«generateStmt(st)»
			«ENDFOR»
		}
		'''
	}
	
	def generateIfStrm(IfStmt s) {
		'''
		if («np.resolveExpression(s.cond)») {
			«FOR trueS : s.trueStmtBlock.stmts»
				«generateStmt(trueS)»
			«ENDFOR»
		}
		«IF s.falseStmtBlock !== null»
		else {
			«FOR falseS : s.falseStmtBlock.stmts»
				«generateStmt(falseS)»
			«ENDFOR»
		}
		«ENDIF»
		'''
	}
		
	def generateGame(Prog p) {
		val n = p.name
		return '''const game: Game = new Game(«n».width, «n».height, «n».x, «n».y, «n».speed);'''
	}
		
	def generateInitValue(Decl d) {

		if (d instanceof VarDecl) {
			if (d.arrSize !== 0) {
				return '''[«d.arrSize»]'''
			}
			if (d.value !== null) {
				return ''' = «np.resolveExpression(d.value.expr)»'''
			}
		} else if (d instanceof ObjDecl) {
			if (d.arrSize !== 0) {
				return '''= arrayOfN(«d.arrSize», «np.type(d)».produce)'''
			}
			if (d.attrAssList !== null) {
				if (np.type(d) == np.RECTANGLE || np.type(d) == np.TRIANGLE) {
					return 
					'''
					 = new «np.type(d)»(«findAttribute(d.attrAssList.attrAss, "x")»,
					 								«findAttribute(d.attrAssList.attrAss, "y")»,
					 								«findAttribute(d.attrAssList.attrAss, "w", "width")»,
					 								«findAttribute(d.attrAssList.attrAss, "h", "height")»,
					 								«findAttribute(d.attrAssList.attrAss, "visible")»,
					 								«findAttribute(d.attrAssList.attrAss, "animation_block")»)'''
				} else if (np.type(d) == np.CIRCLE) {
					return 
					'''
					 = new «np.type(d)»(«findAttribute(d.attrAssList.attrAss, "x")»,
					 								«findAttribute(d.attrAssList.attrAss, "y")»,
					 								«findAttribute(d.attrAssList.attrAss, "radius")»,
					 								«findAttribute(d.attrAssList.attrAss, "visible")»,
					 								«findAttribute(d.attrAssList.attrAss, "animation_block")»)'''
				}

			}
		}
		return "";
	}
	
	def findAttribute(EList<AttrAss> a, String... fields) {
		var AttrAss ret;
		for (f : fields) {
			ret = a.findFirst[
				it.name == f
			]
			if (ret !== null) return np.resolveExpression(ret.expr)
		}
		return "0"
	}
		
}
